From a2b929e0848285016b6c91d77354ed611b25f2ef Mon Sep 17 00:00:00 2001
From: Andrew Walker <awalker@ixsystems.com>
Date: Thu, 13 May 2021 06:37:49 -0400
Subject: [PATCH] s3:smbd - support streams larger than 64 KiB

Add support for streams that are larger than 64 KiB in size. Upper
and lower bound are controlled by the parameters smbd max_xattr_size.
Testing against ReFS on Windows (where ADS size is limited in size
shows the server responding with STATUS_FILESYSTEM_LIMITATION.
Do the same in samba for this case.

Currently, large xattrs are supported in FreeBSD.

Signed-off-by: Andrew Walker <awalker@ixsystems.com>
Reviewed-by: Jeremy Allison <jra@samba.org>

Autobuild-User(master): Jeremy Allison <jra@samba.org>
Autobuild-Date(master): Mon May 10 20:16:21 UTC 2021 on sn-devel-184
---
 source3/modules/vfs_streams_xattr.c | 21 +++++++++++++++++++++
 source3/smbd/smb2_write.c           |  7 ++++++-
 source3/smbd/trans2.c               | 16 ++++++++++++++--
 3 files changed, 41 insertions(+), 3 deletions(-)

diff --git a/source3/modules/vfs_streams_xattr.c b/source3/modules/vfs_streams_xattr.c
index 72032824b93..622eae1b051 100644
--- a/source3/modules/vfs_streams_xattr.c
+++ b/source3/modules/vfs_streams_xattr.c
@@ -932,6 +932,27 @@ static ssize_t streams_xattr_pwrite(vfs_handle_struct *handle,
 		return -1;
 	}
 
+	if ((offset + n) >= lp_smbd_max_xattr_size(SNUM(handle->conn))) {
+		/*
+		 * Requested write is beyond what can be read based on
+		 * samba configuration.
+		 * ReFS returns STATUS_FILESYSTEM_LIMITATION, which causes
+		 * entire file to be skipped by File Explorer. VFAT returns
+		 * NT_STATUS_OBJECT_NAME_COLLISION causes user to be prompted
+		 * to skip writing metadata, but copy data.
+		 */
+		DBG_ERR("Write to xattr [%s] on file [%s] exceeds maximum "
+			"supported extended attribute size. "
+			"Depending on filesystem type and operating system "
+			"(OS) specifics, this value may be increased using "
+			"the value of the parameter: "
+			"smbd max xattr size = <bytes>. Consult OS and "
+			"filesystem manpages prior to increasing this limit.\n",
+			sio->xattr_name, sio->base);
+		errno = EOVERFLOW;
+		return -1;
+	}
+
 	/* Create an smb_filename with stream_name == NULL. */
 	smb_fname_base = synthetic_smb_fname(talloc_tos(),
 					sio->base,
diff --git a/source3/smbd/smb2_write.c b/source3/smbd/smb2_write.c
index e49e623d796..612c89d59d1 100644
--- a/source3/smbd/smb2_write.c
+++ b/source3/smbd/smb2_write.c
@@ -193,7 +193,12 @@ static NTSTATUS smb2_write_complete_internal(struct tevent_req *req,
 	files_struct *fsp = state->fsp;
 
 	if (nwritten == -1) {
-		status = map_nt_error_from_unix(err);
+		if (err == EOVERFLOW &&
+		    is_ntfs_stream_smb_fname(fsp->fsp_name)) {
+			status = NT_STATUS_FILE_SYSTEM_LIMITATION;
+		} else {
+			status = map_nt_error_from_unix(err);
+		}
 
 		DEBUG(2, ("smb2_write failed: %s, file %s, "
 			  "length=%lu offset=%lu nwritten=-1: %s\n",
diff --git a/source3/smbd/trans2.c b/source3/smbd/trans2.c
index 7196b0fcc72..75560744517 100644
--- a/source3/smbd/trans2.c
+++ b/source3/smbd/trans2.c
@@ -249,6 +249,7 @@ NTSTATUS get_ea_value(TALLOC_CTX *mem_ctx,
 	size_t attr_size = 256;
 	char *val = NULL;
 	ssize_t sizeret;
+	size_t max_xattr_size = lp_smbd_max_xattr_size(SNUM(conn));
 
  again:
 
@@ -264,8 +265,8 @@ NTSTATUS get_ea_value(TALLOC_CTX *mem_ctx,
 				ea_name, val, attr_size);
 	}
 
-	if (sizeret == -1 && errno == ERANGE && attr_size != 65536) {
-		attr_size = 65536;
+	if (sizeret == -1 && errno == ERANGE && attr_size < max_xattr_size) {
+		attr_size = max_xattr_size;
 		goto again;
 	}
 
@@ -516,6 +517,17 @@ static NTSTATUS get_ea_list_from_file_path(TALLOC_CTX *mem_ctx,
 			 */
 			TALLOC_FREE(listp);
 			continue;
+		} else if (listp->ea.value.length > 65536) {
+			/*
+			 * SMB clients may report error with file
+			 * if large EA is presented to them.
+			 */
+			DBG_ERR("EA [%s] on file [%s] exceeds "
+				"maximum permitted EA size of 64KiB: %zu\n.",
+				listp->ea.name, fsp_str_dbg(fsp),
+				listp->ea.value.length);
+			TALLOC_FREE(listp);
+			continue;
 		}
 
 		push_ascii_fstring(dos_ea_name, listp->ea.name);
-- 
2.31.1

