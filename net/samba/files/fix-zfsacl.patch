From 91c36b9fb35e81412c6851f7d2a63bb5a0aef08e Mon Sep 17 00:00:00 2001
From: Andrew Walker <awalker@ixsystems.com>
Date: Wed, 19 May 2021 18:23:36 -0400
Subject: [PATCH] s3:modules:zfsacl - add O_EMPTY_PATH support

Convert pathref fds into IO fds though O_EMPTY_PATH when
available (FreeBSD 13 and later).

Signed-off-by: Andrew Walker <awalker@ixsystems.com>
---
 source3/modules/vfs_zfsacl.c | 133 ++++++++++++++++++++++++++++++-----
 1 file changed, 117 insertions(+), 16 deletions(-)

diff --git a/source3/modules/vfs_zfsacl.c b/source3/modules/vfs_zfsacl.c
index a526ffa19aa..8ffc15891f3 100644
--- a/source3/modules/vfs_zfsacl.c
+++ b/source3/modules/vfs_zfsacl.c
@@ -28,6 +28,7 @@
 #include "nfs4_acls.h"
 
 #ifdef HAVE_FREEBSD_SUNACL_H
+#include <sys/acl.h>
 #include "sunacl.h"
 #endif
 
@@ -47,6 +48,33 @@ struct zfsacl_config_data {
  * read the local file's acls and return it in NT form
  * using the NFSv4 format conversion
  */
+
+#ifdef O_EMPTY_PATH
+static int convert_pathref_reopen(struct files_struct *fsp, int flags)
+{
+	int opath_fd, out_fd;
+
+	if (!VALID_STAT(fsp->fsp_name->st)) {
+		NTSTATUS status;
+		status = vfs_stat_fsp(fsp);
+		if (!NT_STATUS_IS_OK(status)) {
+			DBG_ERR("%s: vfs_stat_fsp() failed: %s\n",
+				fsp_str_dbg(fsp), strerror(errno));
+			return -1;
+		}
+	}
+
+	flags = S_ISDIR(fsp->fsp_name->st.st_ex_mode) ? O_DIRECTORY : flags;
+	opath_fd = fsp_get_pathref_fd(fsp);
+	out_fd = openat(opath_fd, "", flags | O_EMPTY_PATH);
+	if (out_fd == -1) {
+		DBG_ERR("%s: failed to re-open pathref descriptor: %s\n",
+			fsp_str_dbg(fsp), strerror(errno));
+	}
+	return out_fd;
+}
+#endif
+
 static NTSTATUS zfs_get_nt_acl_common(struct connection_struct *conn,
 				      TALLOC_CTX *mem_ctx,
 				      const struct smb_filename *smb_fname,
@@ -158,6 +186,65 @@ static NTSTATUS zfs_get_nt_acl_common(struct connection_struct *conn,
 	return NT_STATUS_OK;
 }
 
+static int fsp_do_acl_op(struct files_struct *fsp,
+			 int op,
+			 int naces,
+			 ace_t *acebuf)
+{
+	int fd, rv;
+	bool must_close = false;
+
+#ifdef O_EMPTY_PATH
+	if (fsp->fsp_flags.is_pathref) {
+		fd = convert_pathref_reopen(fsp, 0);
+
+		/*
+		 * We may lack READ_DATA or WRITE_DATA,
+		 * but have READ_ACL or WRITE_ACL. So
+		 * fallback to path-based on EACCES.
+		 */
+		if ((fd == -1) && (errno == EACCES)) {
+			goto path_based;
+		}
+		else if (fd == -1) {
+			return -1;
+		}
+		must_close = true;
+	} else {
+		fd = fsp_get_io_fd(fsp);
+	}
+#else
+	if (fsp->fsp_flags.is_pathref) {
+		goto path_based;
+	}
+	fd = fsp_get_io_fd(fsp);
+#endif
+
+	rv = facl(fd, op, naces, acebuf);
+	if (must_close) {
+		close(fd);
+	}
+	return rv;
+
+path_based:
+	if (fsp->fsp_flags.have_proc_fds) {
+		const char *p = NULL;
+		char buf[PATH_MAX];
+
+		p = sys_proc_fd_path(fd, buf, sizeof(buf));
+		if (p == NULL) {
+			return -1;
+		}
+
+		return acl(p, op, naces, acebuf);
+	}
+
+	/*
+	 * This is no longer a handle-based call.
+	 */
+	return acl(fsp->fsp_name->base_name, op, naces, acebuf);
+}
+
 /* call-back function processing the NT acl -> ZFS acl using NFSv4 conv. */
 static bool zfs_process_smbacl(vfs_handle_struct *handle, files_struct *fsp,
 			       struct SMB4ACL_T *smbacl)
@@ -235,12 +322,7 @@ static bool zfs_process_smbacl(vfs_handle_struct *handle, files_struct *fsp,
 	SMB_ASSERT(i == naces);
 
 	/* store acl */
-	if (fsp->fh->fd != -1) {
-		rv = facl(fsp->fh->fd, ACE_SETACL, naces, acebuf);
-	}
-	else {
-		rv = acl(fsp->fsp_name->base_name, ACE_SETACL, naces, acebuf);
-	}
+	rv = fsp_do_acl_op(fsp, ACE_SETACL, naces, acebuf);
 	if (rv != 0) {
 		if(errno == ENOSYS) {
 			DEBUG(9, ("acl(ACE_SETACL, %s): Operation is not "
@@ -285,6 +367,16 @@ static int get_zfsacl(TALLOC_CTX *mem_ctx,
 	int naces, rv;
 	ace_t *acebuf = NULL;
 
+#ifdef HAVE_FREEBSD_SUNACL_H
+	/*
+	 * libsunacl has no optimization for ACE_GETACLCNT. Instead it
+	 * calls acl_init(ACL_MAX_ENTRIES) and performs normal acl-related
+	 * system call. This means, it's simpler in case of FreeBSD to
+	 * skip the extra allocation and syscall (with associated ZFS locks),
+	 * and just create a buffer for ACL_MAX_ENTRIES.
+	 */
+	naces = ACL_MAX_ENTRIES;
+#else
 	naces = acl(smb_fname->base_name, ACE_GETACLCNT, 0, NULL);
 	if (naces == -1) {
 		int dbg_level = 10;
@@ -296,6 +388,8 @@ static int get_zfsacl(TALLOC_CTX *mem_ctx,
 				  smb_fname->base_name, strerror(errno)));
 		return naces;
 	}
+#endif
+
 	acebuf = talloc_size(mem_ctx, sizeof(ace_t)*naces);
 	if (acebuf == NULL) {
 		errno = ENOMEM;
@@ -310,7 +404,7 @@ static int get_zfsacl(TALLOC_CTX *mem_ctx,
 	}
 
 	*outbuf = acebuf;
-	return naces;
+	return rv;
 }
 
 static int fget_zfsacl(TALLOC_CTX *mem_ctx,
@@ -319,12 +413,19 @@ static int fget_zfsacl(TALLOC_CTX *mem_ctx,
 {
 	int naces, rv;
 	ace_t *acebuf = NULL;
+	bool must_close = false;
 
-	if (fsp->fh->fd == -1) {
-		return get_zfsacl(mem_ctx, fsp->fsp_name, outbuf);
-	}
-
-	naces = facl(fsp->fh->fd, ACE_GETACLCNT, 0, NULL);
+#ifdef HAVE_FREEBSD_SUNACL_H
+	/*
+	 * libsunacl has no optimization for ACE_GETACLCNT. Instead it
+	 * calls acl_init(ACL_MAX_ENTRIES) and performs normal acl-related
+	 * system call. This means, it's simpler in case of FreeBSD to
+	 * skip the extra allocation and syscall (with associated ZFS locks),
+	 * and just create a buffer for ACL_MAX_ENTRIES.
+	 */
+	naces = ACL_MAX_ENTRIES;
+#else
+	naces = fsp_do_acl_op(fsp, ACE_GETACLCNT, 0, NULL);
 	if (naces == -1) {
 		int dbg_level = 10;
 
@@ -335,22 +436,22 @@ static int fget_zfsacl(TALLOC_CTX *mem_ctx,
 				  fsp_str_dbg(fsp), strerror(errno)));
 		return naces;
 	}
-
+#endif
 	acebuf = talloc_size(mem_ctx, sizeof(ace_t)*naces);
 	if (acebuf == NULL) {
 		errno = ENOMEM;
 		return -1;
 	}
 
-	rv = facl(fsp->fh->fd, ACE_GETACL, naces, acebuf);
+	rv = fsp_do_acl_op(fsp, ACE_GETACL, naces, acebuf);
 	if (rv == -1) {
 		DBG_DEBUG("acl(ACE_GETACL, %s): %s ",
 			  fsp_str_dbg(fsp), strerror(errno));
-		return -1;
 	}
 
 	*outbuf = acebuf;
-	return naces;
+
+	return rv;
 }
 
 static NTSTATUS zfsacl_fget_nt_acl(struct vfs_handle_struct *handle,
-- 
2.31.1

