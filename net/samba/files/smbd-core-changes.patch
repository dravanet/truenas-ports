From c0edb92766a4b9fd346174631602cdf48e58056b Mon Sep 17 00:00:00 2001
From: Andrew Walker <awalker@ixsystems.com>
Date: Thu, 13 May 2021 07:03:55 -0400
Subject: [PATCH] Add TrueNAS-specific fixes to smbd

- O_EMPTY_PATH support
- quota support fo rusers in BA
- initial support for ACL branding (POSIX vs NFSv4)
- fixes for case-insensitive renames
---
 lib/util/memcache.c           |   1 +
 lib/util/memcache.h           |   1 +
 source3/include/vfs.h         |   8 +++
 source3/lib/system.c          |  19 +++++
 source3/modules/vfs_default.c | 126 ++++++++++++++++++++++++++++------
 source3/smbd/fake_file.c      |  40 ++++++++---
 source3/smbd/globals.h        |   1 +
 source3/smbd/open.c           |  59 +++++++++++++---
 source3/smbd/reply.c          |  29 ++++++--
 source3/smbd/trans2.c         |  21 +++++-
 10 files changed, 260 insertions(+), 45 deletions(-)

diff --git a/lib/util/memcache.c b/lib/util/memcache.c
index 7b0b27eaddb..7b0c0efce28 100644
--- a/lib/util/memcache.c
+++ b/lib/util/memcache.c
@@ -60,6 +60,7 @@ static bool memcache_is_talloc(enum memcache_number n)
 	case SINGLETON_CACHE_TALLOC:
 	case SHARE_MODE_LOCK_CACHE:
 	case GETWD_CACHE:
+	case ZFS_CACHE:
 	case VIRUSFILTER_SCAN_RESULTS_CACHE_TALLOC:
 		result = true;
 		break;
diff --git a/lib/util/memcache.h b/lib/util/memcache.h
index 4331c2f1465..fb3dc5eac02 100644
--- a/lib/util/memcache.h
+++ b/lib/util/memcache.h
@@ -46,6 +46,7 @@ enum memcache_number {
 	SMB1_SEARCH_OFFSET_MAP,
 	SHARE_MODE_LOCK_CACHE,	/* talloc */
 	VIRUSFILTER_SCAN_RESULTS_CACHE_TALLOC, /* talloc */
+	ZFS_CACHE,
 	DFREE_CACHE,
 };
 
diff --git a/source3/include/vfs.h b/source3/include/vfs.h
index 49726618c5c..4363f96687d 100644
--- a/source3/include/vfs.h
+++ b/source3/include/vfs.h
@@ -371,6 +371,13 @@ typedef union unid_t {
 } unid_t;
 
 struct fd_handle;
+enum acl_brand {
+	SMB_ACL_BRAND_POSIX,
+	SMB_ACL_BRAND_NFS40,
+	SMB_ACL_BRAND_NFS41,
+	SMB_ACL_BRAND_RICH,
+	SMB_ACL_BRAND_NONE,
+};
 
 struct fsp_lease {
 	size_t ref_count;
@@ -689,6 +696,7 @@ typedef struct connection_struct {
 	   sub second timestamps on files
 	   and directories when setting time ? */
 	enum timestamp_set_resolution ts_res;
+	enum acl_brand aclbrand;
 	char *connectpath;
 	struct files_struct *cwd_fsp; /* Working directory. */
 	bool tcon_done;
diff --git a/source3/lib/system.c b/source3/lib/system.c
index 8ea2af9f93b..113208c7afd 100644
--- a/source3/lib/system.c
+++ b/source3/lib/system.c
@@ -1054,6 +1054,25 @@ bool sys_have_proc_fds(void)
 		return have_proc_fds;
 	}
 
+#ifdef FREEBSD
+	/*
+	 * FreeBSD may have support for O_PATH opens, but not an
+	 * additional feature used by Samba to convert pathref opens
+	 * to regular ones. We _must_ return that we don't have proc_fds
+	 * in this case.
+	 */
+	have_proc_fds = false;
+	checked = true;
+#ifndef O_EMPTY_PATH
+	DBG_ERR("FreeBSD version lacks support for O_EMPTY_PATH, which "
+		"is required in order to use pathref functionality in "
+		"Samba's virtual filesystem. Samba will continue to "
+		"operate correctly, but performance may be "
+		"significantly degraded until FreeBSD is upgraded to a "
+		"version that supports this feature.");
+#endif
+	return have_proc_fds;
+#endif
 	for (p = &proc_fd_patterns[0]; p->test_path != NULL; p++) {
 		ret = stat(p->test_path, &sb);
 		if (ret != 0) {
diff --git a/source3/modules/vfs_default.c b/source3/modules/vfs_default.c
index 8d592bbad64..07da6cec058 100644
--- a/source3/modules/vfs_default.c
+++ b/source3/modules/vfs_default.c
@@ -18,9 +18,11 @@
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 
+#include <sys/param.h>
 #include "includes.h"
 #include "system/time.h"
 #include "system/filesys.h"
+#include "modules/smb_libzfs.h"
 #include "smbd/smbd.h"
 #include "smbd/globals.h"
 #include "ntioctl.h"
@@ -41,16 +43,32 @@
 #undef DBGC_CLASS
 #define DBGC_CLASS DBGC_VFS
 
+#define ROBOCOPYTS 315619200
+
 /* Check for NULL pointer parameters in vfswrap_* functions */
 
 /* We don't want to have NULL function pointers lying around.  Someone
    is sure to try and execute them.  These stubs are used to prevent
    this possibility. */
 
+#ifdef O_EMPTY_PATH
+static int convert_pathref_reopen(files_struct *fsp, int flags)
+{
+	int opath_fd, out_fd;
+	opath_fd = fsp_get_pathref_fd(fsp);
+	out_fd = openat(opath_fd, "", flags | O_EMPTY_PATH);
+	if (out_fd == -1) {
+		DBG_ERR("Failed to re-open pathref descriptor on %s: %s\n",
+			fsp_str_dbg(fsp), strerror(errno));
+	}
+	return out_fd;
+}
+#endif
+
 static int vfswrap_connect(vfs_handle_struct *handle, const char *service, const char *user)
 {
 	handle->conn->have_proc_fds = sys_have_proc_fds();
-	return 0;    /* Return >= 0 for success */
+	return 0;
 }
 
 static void vfswrap_disconnect(vfs_handle_struct *handle)
@@ -79,32 +97,14 @@ static int vfswrap_get_quota(struct vfs_handle_struct *handle,
 				unid_t id,
 				SMB_DISK_QUOTA *qt)
 {
-#ifdef HAVE_SYS_QUOTAS
-	int result;
-
-	START_PROFILE(syscall_get_quota);
-	result = sys_get_quota(smb_fname->base_name, qtype, id, qt);
-	END_PROFILE(syscall_get_quota);
-	return result;
-#else
 	errno = ENOSYS;
 	return -1;
-#endif
 }
 
 static int vfswrap_set_quota(struct vfs_handle_struct *handle, enum SMB_QUOTA_TYPE qtype, unid_t id, SMB_DISK_QUOTA *qt)
 {
-#ifdef HAVE_SYS_QUOTAS
-	int result;
-
-	START_PROFILE(syscall_set_quota);
-	result = sys_set_quota(handle->conn->connectpath, qtype, id, qt);
-	END_PROFILE(syscall_set_quota);
-	return result;
-#else
 	errno = ENOSYS;
 	return -1;
-#endif
 }
 
 static int vfswrap_get_shadow_copy_data(struct vfs_handle_struct *handle,
@@ -1978,7 +1978,7 @@ static void vfswrap_offload_write_cleanup(struct tevent_req *req,
 		req, struct vfswrap_offload_write_state);
 	bool ok;
 
-	if (state->dst_fsp == NULL) {
+	if (state->dst_fsp == NULL || state->dst_fsp->conn == NULL) {
 		return;
 	}
 
@@ -2518,6 +2518,18 @@ static struct smb_filename *vfswrap_getwd(vfs_handle_struct *handle,
  nsec timestamp resolution call. Convert down to whatever the underlying
  system will support.
 **********************************************************************/
+static bool is_robocopy_init(struct smb_file_time *ft)
+{
+	if (!null_timespec(ft->atime) ||
+	    !null_timespec(ft->create_time)) {
+		return false;
+	}
+	if (!null_timespec(ft->mtime) &&
+	    ft->mtime.tv_sec == ROBOCOPYTS) {
+		return true;
+	}
+	return false;
+}
 
 static int vfswrap_ntimes(vfs_handle_struct *handle,
 			  const struct smb_filename *smb_fname,
@@ -2557,6 +2569,9 @@ static int vfswrap_ntimes(vfs_handle_struct *handle,
 
 #if defined(HAVE_UTIMENSAT)
 	if (ft != NULL) {
+		if (is_robocopy_init(ft)) {
+			return 0;
+		}
 		struct timespec ts[2];
 		ts[0] = ft->atime;
 		ts[1] = ft->mtime;
@@ -3218,6 +3233,20 @@ static int vfswrap_sys_acl_set_fd(vfs_handle_struct *handle,
 		return sys_acl_set_fd(handle, fsp, theacl);
 	}
 
+#ifdef O_EMPTY_PATH
+	int tmp_fd, result, flags;
+	flags = fsp->fsp_flags.is_directory ? O_DIRECTORY : O_WRONLY;
+	tmp_fd = convert_pathref_reopen(fsp, flags);
+	if (tmp_fd == -1) {
+		DBG_ERR("Failed to re-open pathref descriptor on %s: %s\n",
+			fsp_str_dbg(fsp), strerror(errno));
+		return -1;
+	}
+	/*fixme*/
+	result = sys_acl_set_fd(handle, fsp, theacl);
+	close(tmp_fd);
+	return result;
+#else
 	if (fsp->fsp_flags.have_proc_fds) {
 		int fd = fsp_get_pathref_fd(fsp);
 		struct smb_filename smb_fname;
@@ -3246,6 +3275,7 @@ static int vfswrap_sys_acl_set_fd(vfs_handle_struct *handle,
 				fsp->fsp_name,
 				type,
 				theacl);
+#endif
 }
 
 static int vfswrap_sys_acl_delete_def_file(vfs_handle_struct *handle,
@@ -3596,6 +3626,18 @@ static ssize_t vfswrap_fgetxattr(struct vfs_handle_struct *handle,
 		return fgetxattr(fd, name, value, size);
 	}
 
+#ifdef O_EMPTY_PATH
+	int tmp_fd, result;
+	tmp_fd = convert_pathref_reopen(fsp, 0);
+	if (tmp_fd == -1) {
+		DBG_ERR("Failed to re-open pathref descriptor on %s: %s\n",
+			fsp_str_dbg(fsp), strerror(errno));
+		return -1;
+	}
+	result = fgetxattr(tmp_fd, name, value, size);
+	close(tmp_fd);
+	return result;
+#else
 	if (fsp->fsp_flags.have_proc_fds) {
 		const char *p = NULL;
 		char buf[PATH_MAX];
@@ -3612,6 +3654,7 @@ static ssize_t vfswrap_fgetxattr(struct vfs_handle_struct *handle,
 	 * This is no longer a handle based call.
 	 */
 	return getxattr(fsp->fsp_name->base_name, name, value, size);
+#endif
 }
 
 static ssize_t vfswrap_listxattr(struct vfs_handle_struct *handle,
@@ -3630,6 +3673,19 @@ static ssize_t vfswrap_flistxattr(struct vfs_handle_struct *handle, struct files
 		return flistxattr(fd, list, size);
 	}
 
+#ifdef O_EMPTY_PATH
+	int tmp_fd, result;
+	tmp_fd = convert_pathref_reopen(fsp, 0);
+	if (tmp_fd == -1) {
+		DBG_ERR("Failed to re-open pathref descriptor on %s: %s\n",
+			fsp_str_dbg(fsp), strerror(errno));
+		return -1;
+	}
+	result = flistxattr(tmp_fd, list, size);
+	close(tmp_fd);
+	return result;
+#else
+
 	if (fsp->fsp_flags.have_proc_fds) {
 		const char *p = NULL;
 		char buf[PATH_MAX];
@@ -3646,6 +3702,7 @@ static ssize_t vfswrap_flistxattr(struct vfs_handle_struct *handle, struct files
 	 * This is no longer a handle based call.
 	 */
 	return listxattr(fsp->fsp_name->base_name, list, size);
+#endif
 }
 
 static int vfswrap_removexattr(struct vfs_handle_struct *handle,
@@ -3663,6 +3720,20 @@ static int vfswrap_fremovexattr(struct vfs_handle_struct *handle, struct files_s
 		return fremovexattr(fd, name);
 	}
 
+#ifdef O_EMPTY_PATH
+	int tmp_fd, result, flags;
+	flags = fsp->fsp_flags.is_directory ? O_DIRECTORY : O_WRONLY;
+	tmp_fd = convert_pathref_reopen(fsp, flags);
+	if (tmp_fd == -1) {
+		DBG_ERR("Failed to re-open pathref descriptor on %s: %s\n",
+			fsp_str_dbg(fsp), strerror(errno));
+		return -1;
+	}
+	result = fremovexattr(tmp_fd, name);
+	close(tmp_fd);
+	return result;
+#else
+
 	if (fsp->fsp_flags.have_proc_fds) {
 		const char *p = NULL;
 		char buf[PATH_MAX];
@@ -3679,6 +3750,7 @@ static int vfswrap_fremovexattr(struct vfs_handle_struct *handle, struct files_s
 	 * This is no longer a handle based call.
 	 */
 	return removexattr(fsp->fsp_name->base_name, name);
+#endif
 }
 
 static int vfswrap_setxattr(struct vfs_handle_struct *handle,
@@ -3699,6 +3771,19 @@ static int vfswrap_fsetxattr(struct vfs_handle_struct *handle, struct files_stru
 		return fsetxattr(fd, name, value, size, flags);
 	}
 
+#ifdef O_EMPTY_PATH
+	int tmp_fd, result;
+	tmp_fd = convert_pathref_reopen(fsp, 0);
+	if (tmp_fd == -1) {
+		DBG_ERR("Failed to re-open pathref descriptor on %s: %s\n",
+			fsp_str_dbg(fsp), strerror(errno));
+		return -1;
+	}
+	result = fsetxattr(tmp_fd, name, value, size, flags);
+	close(tmp_fd);
+	return result;
+#else
+
 	if (fsp->fsp_flags.have_proc_fds) {
 		const char *p = NULL;
 		char buf[PATH_MAX];
@@ -3715,6 +3800,7 @@ static int vfswrap_fsetxattr(struct vfs_handle_struct *handle, struct files_stru
 	 * This is no longer a handle based call.
 	 */
 	return setxattr(fsp->fsp_name->base_name, name, value, size, flags);
+#endif
 }
 
 static bool vfswrap_aio_force(struct vfs_handle_struct *handle, struct files_struct *fsp)
diff --git a/source3/smbd/fake_file.c b/source3/smbd/fake_file.c
index c4c81dd19f9..a250b64d878 100644
--- a/source3/smbd/fake_file.c
+++ b/source3/smbd/fake_file.c
@@ -22,6 +22,7 @@
 #include "smbd/globals.h"
 #include "fake_file.h"
 #include "auth.h"
+#include "privileges.h"
 
 struct fake_file_type {
 	const char *name;
@@ -130,6 +131,8 @@ NTSTATUS open_fake_file(struct smb_request *req, connection_struct *conn,
 		loadparm_s3_global_substitution();
 	files_struct *fsp = NULL;
 	NTSTATUS status;
+	bool is_disk_op;
+	int ret;
 
 	status = smbd_calculate_access_mask(conn,
 					conn->cwd_fsp,
@@ -146,15 +149,34 @@ NTSTATUS open_fake_file(struct smb_request *req, connection_struct *conn,
 		return status;
 	}
 
-	/* access check */
-	if (geteuid() != sec_initial_uid()) {
-		DEBUG(3, ("open_fake_file_shared: access_denied to "
-			  "service[%s] file[%s] user[%s]\n",
-			  lp_servicename(talloc_tos(), lp_sub, SNUM(conn)),
-			  smb_fname_str_dbg(smb_fname),
-			  conn->session_info->unix_info->unix_name));
-		return NT_STATUS_ACCESS_DENIED;
-
+	/* access check
+	 * Allow access to QUOTA fake file if user has DISK_OPERATOR
+	 * privileges. This is a subset of local admin rights.
+	 */
+	switch(fake_file_type){
+	case FAKE_FILE_TYPE_QUOTA:
+		is_disk_op = security_token_has_privilege(
+			conn->session_info->security_token,
+			SEC_PRIV_DISK_OPERATOR);
+		if (!is_disk_op) {
+			DBG_NOTICE("Access denied to "
+				   "service[%s] file[%s]. User [%s] "
+				   "lacks SE_PRIV_DISK_OPERATOR\n",
+				   lp_servicename(talloc_tos(), lp_sub, SNUM(conn)),
+				   smb_fname_str_dbg(smb_fname),
+				   conn->session_info->unix_info->unix_name);
+			return NT_STATUS_ACCESS_DENIED;
+		}
+		break;
+	default:
+		if (geteuid() != sec_initial_uid()) {
+			DEBUG(3, ("open_fake_file_shared: access_denied to "
+				  "service[%s] file[%s] user[%s]\n",
+				  lp_servicename(talloc_tos(), lp_sub, SNUM(conn)),
+				  smb_fname_str_dbg(smb_fname),
+				  conn->session_info->unix_info->unix_name));
+			return NT_STATUS_ACCESS_DENIED;
+		}
 	}
 
 	status = file_new(req, conn, &fsp);
diff --git a/source3/smbd/globals.h b/source3/smbd/globals.h
index 4685b6971d3..5bd51680e66 100644
--- a/source3/smbd/globals.h
+++ b/source3/smbd/globals.h
@@ -24,6 +24,7 @@
 #include "system/select.h"
 #include "librpc/gen_ndr/smbXsrv.h"
 #include "smbprofile.h"
+#include "modules/smb_libzfs.h"
 
 #ifdef USE_DMAPI
 struct smbd_dmapi_context;
diff --git a/source3/smbd/open.c b/source3/smbd/open.c
index 87c14bb4367..aae968fc62f 100644
--- a/source3/smbd/open.c
+++ b/source3/smbd/open.c
@@ -1193,6 +1193,27 @@ static NTSTATUS reopen_from_procfd(struct files_struct *fsp,
 		return NT_STATUS_INVALID_HANDLE;
 	}
 
+#ifdef O_EMPTY_PATH
+	/*
+	 * This is the FreeBSD method of converting
+	 * an O_PATH descriptor into a regular open.
+	 * In this situation, dirfsp will be the
+	 * the pathref fsp / target. The path for the
+	 * openat syscall is an empty string, and
+	 * the O_EMPTY_PATH flag must be added.
+	 */
+	proc_fname = (struct smb_filename) {
+		.base_name = "",
+	};
+
+	fsp->fsp_flags.is_pathref = false;
+	new_fd = SMB_VFS_OPENAT(fsp->conn,
+				fsp,
+				&proc_fname,
+				fsp,
+				flags | O_EMPTY_PATH,
+				mode);
+#else
 	p = sys_proc_fd_path(old_fd, buf, sizeof(buf));
 	if (p == NULL) {
 		return NT_STATUS_NO_MEMORY;
@@ -1210,6 +1231,7 @@ static NTSTATUS reopen_from_procfd(struct files_struct *fsp,
 				fsp,
 				flags,
 				mode);
+#endif
 	if (new_fd == -1) {
 		status = map_nt_error_from_unix(errno);
 		SMB_VFS_CLOSE(fsp);
@@ -3114,13 +3136,13 @@ static bool open_match_attributes(connection_struct *conn,
 		  (unsigned int)*returned_unx_mode ));
 
 	/* If we're mapping SYSTEM and HIDDEN ensure they match. */
-	if (lp_map_system(SNUM(conn)) || lp_store_dos_attributes(SNUM(conn))) {
+	if (lp_map_system(SNUM(conn)) || lp_store_dos_attributes(SNUM(conn)) || lp_kernel_dosmodes(SNUM(conn))) {
 		if ((old_dos_attr & FILE_ATTRIBUTE_SYSTEM) &&
 		    !(new_dos_attr & FILE_ATTRIBUTE_SYSTEM)) {
 			return False;
 		}
 	}
-	if (lp_map_hidden(SNUM(conn)) || lp_store_dos_attributes(SNUM(conn))) {
+	if (lp_map_hidden(SNUM(conn)) || lp_store_dos_attributes(SNUM(conn)) || lp_kernel_dosmodes(SNUM(conn))) {
 		if ((old_dos_attr & FILE_ATTRIBUTE_HIDDEN) &&
 		    !(new_dos_attr & FILE_ATTRIBUTE_HIDDEN)) {
 			return False;
@@ -3825,13 +3847,24 @@ static NTSTATUS open_file_ntcreate(connection_struct *conn,
 	/*
 	 * Ensure we pay attention to default ACLs on directories if required.
 	 */
-
-        if ((flags2 & O_CREAT) && lp_inherit_acls(SNUM(conn)) &&
-	    (def_acl = directory_has_default_acl(conn,
-				conn->cwd_fsp,
-				parent_dir_fname)))
-	{
-		unx_mode = (0777 & lp_create_mask(SNUM(conn)));
+	switch(conn->aclbrand) {
+	case SMB_ACL_BRAND_POSIX:
+		if ((flags2 & O_CREAT) && lp_inherit_acls(SNUM(conn)) &&
+		    (def_acl = directory_has_default_acl(conn, conn->cwd_fsp, parent_dir_fname))) {
+			unx_mode = (0777 & lp_create_mask(SNUM(conn)));
+		}
+		break;
+	case SMB_ACL_BRAND_NFS40:
+	case SMB_ACL_BRAND_NFS41:
+	default:
+		/*
+		 * Pass along to VFS to determine whether the ACL has
+		 * any inheriting entries.
+		 */
+		if (flags2 & O_CREAT) {
+			def_acl = directory_has_default_acl(conn, conn->cwd_fsp, parent_dir_fname);
+		}
+		break;
 	}
 
 	DEBUG(4,("calling open_file with flags=0x%X flags2=0x%X mode=0%o, "
@@ -4195,6 +4228,10 @@ static NTSTATUS open_file_ntcreate(connection_struct *conn,
 				}
 			}
 		}
+		else if (lp_kernel_dosmodes(SNUM(conn)) && !posix_open) {
+			SMB_VFS_SET_DOS_ATTRIBUTES(conn, smb_fname,
+						   new_dos_attributes | FILE_ATTRIBUTE_ARCHIVE);
+		}
 	}
 
 	/* Determine sparse flag. */
@@ -4399,6 +4436,10 @@ static NTSTATUS mkdir_internal(connection_struct *conn,
 					 parent_dir_fname, true);
 		}
 	}
+	else if (lp_kernel_dosmodes(SNUM(conn)) && !posix_open) {
+		SMB_VFS_SET_DOS_ATTRIBUTES(conn, smb_dname,
+					   file_attributes | FILE_ATTRIBUTE_DIRECTORY);
+	}
 
 	if (lp_inherit_permissions(SNUM(conn))) {
 		inherit_access_posix_acl(conn, parent_dir_fname,
diff --git a/source3/smbd/reply.c b/source3/smbd/reply.c
index 8bfe15510c4..7e8d135de6d 100644
--- a/source3/smbd/reply.c
+++ b/source3/smbd/reply.c
@@ -7554,7 +7554,9 @@ NTSTATUS rename_internals_fsp(connection_struct *conn,
 	NTSTATUS status = NT_STATUS_OK;
 	struct share_mode_lock *lck = NULL;
 	uint32_t access_mask = SEC_DIR_ADD_FILE;
-	bool dst_exists, old_is_stream, new_is_stream;
+	bool dst_exists, old_is_stream, new_is_stream, is_same_fileid;
+	struct file_id fileid_src;
+	struct file_id fileid_dst;
 	int ret;
 
 	status = check_name(conn, smb_fname_dst_in);
@@ -7567,10 +7569,17 @@ NTSTATUS rename_internals_fsp(connection_struct *conn,
 		return status;
 	}
 
+/*
+        FIXME: OS-X clients will set a RH lease on AFP_Resource streams which results
+        in a share-mode lock being set on a file. Which causes the following check to
+        prevent users from renaming the file until the OS-X client with the lease disconnects.
+        This is incorrect behavior per MS docs.
+ */
+/*
 	if (file_has_open_streams(fsp)) {
 		return NT_STATUS_ACCESS_DENIED;
 	}
-
+ */
 	/* Make a copy of the dst smb_fname structs */
 
 	smb_fname_dst = cp_smb_filename(ctx, smb_fname_dst_in);
@@ -7716,7 +7725,19 @@ NTSTATUS rename_internals_fsp(connection_struct *conn,
 
 	dst_exists = SMB_VFS_STAT(conn, smb_fname_dst) == 0;
 
-	if(!replace_if_exists && dst_exists) {
+	/*
+	 * Some filesystems are case-insensitive, but case-preserving
+	 * Compare fileid in this situation to determine whether the
+	 * source and destination are the same file. If this is the
+	 * case, then bypass these checks and hand off to VFS_RENAME
+	 * and hope that a VFS module is enabled that has special
+	 * handling for this situation.
+	 */
+	fileid_src = vfs_file_id_from_sbuf(conn, &fsp->fsp_name->st);
+	fileid_dst = vfs_file_id_from_sbuf(conn, &smb_fname_dst->st);
+	is_same_fileid = file_id_equal(&fileid_src, &fileid_dst);
+
+	if(!replace_if_exists && dst_exists && !is_same_fileid) {
 		DEBUG(3, ("rename_internals_fsp: dest exists doing rename "
 			  "%s -> %s\n", smb_fname_str_dbg(fsp->fsp_name),
 			  smb_fname_str_dbg(smb_fname_dst)));
@@ -7734,7 +7755,7 @@ NTSTATUS rename_internals_fsp(connection_struct *conn,
 		SMB_ASSERT(smb_fname_dst_in->fsp == NULL);
 	}
 
-	if (dst_exists) {
+	if (dst_exists && !is_same_fileid) {
 		struct file_id fileid = vfs_file_id_from_sbuf(conn,
 		    &smb_fname_dst->st);
 		files_struct *dst_fsp = file_find_di_first(conn->sconn,
diff --git a/source3/smbd/trans2.c b/source3/smbd/trans2.c
index 7196b0fcc72..0899b368b60 100644
--- a/source3/smbd/trans2.c
+++ b/source3/smbd/trans2.c
@@ -3937,12 +3937,21 @@ cBytesSector=%u, cUnitTotal=%u, cUnitAvail=%d\n", (unsigned int)bsize, (unsigned
 
 			ZERO_STRUCT(fsp);
 			ZERO_STRUCT(quotas);
+			bool allowed_user;
+			if ((get_current_uid(conn) == 0) || (security_token_has_privilege(
+			   conn->session_info->security_token, SEC_PRIV_DISK_OPERATOR) == 0)) {
+				allowed_user = true;
+			}
+
+
 
 			fsp.conn = conn;
 			fsp.fnum = FNUM_FIELD_INVALID;
 
-			/* access check */
-			if (get_current_uid(conn) != 0) {
+			/* access check
+			 * Allow access in case we have SEC_PRIV_DISK_OPERATOR.
+			 */
+			if ( !allowed_user ) {
 				DEBUG(0,("get_user_quota: access_denied "
 					 "service [%s] user [%s]\n",
 					 lp_servicename(talloc_tos(), lp_sub, SNUM(conn)),
@@ -4241,11 +4250,17 @@ static NTSTATUS smb_set_fsquota(connection_struct *conn,
 		loadparm_s3_global_substitution();
 	NTSTATUS status;
 	SMB_NTQUOTA_STRUCT quotas;
+	bool allowed_user;
+
+	if ((get_current_uid(conn) == 0) || (security_token_has_privilege(
+	   conn->session_info->security_token, SEC_PRIV_DISK_OPERATOR) == 0)) {
+		allowed_user = true;
+	}
 
 	ZERO_STRUCT(quotas);
 
 	/* access check */
-	if ((get_current_uid(conn) != 0) || !CAN_WRITE(conn)) {
+	if ((!allowed_user) || !CAN_WRITE(conn)) {
 		DEBUG(3, ("set_fsquota: access_denied service [%s] user [%s]\n",
 			  lp_servicename(talloc_tos(), lp_sub, SNUM(conn)),
 			  conn->session_info->unix_info->unix_name));
-- 
2.31.1

